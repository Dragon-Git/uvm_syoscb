<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SyoSil ApS UVM Scoreboard: How to integrate the UVM scoreboard</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SyoSil ApS UVM Scoreboard
   &#160;<span id="projectnumber">1.0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to integrate the UVM scoreboard </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The UVM scoreboard is easily integrated into your existing testbench environment. The following steps should be followed to start using the UVM scoreboard:</p>
<ol type="1">
<li>Compile the UVM scoreboard</li>
<li>Access the UVM scoreboard from your own code</li>
<li>Perform cactory overrides</li>
<li>Instantiate the UVM scoreboard</li>
<li>Configure the UVM scoreboard</li>
<li>Add sequence items to the scoreboard</li>
<li>Use the scoreboard wrapper for multiple similar scoreboards</li>
</ol>
<h1><a class="anchor" id="sCompile"></a>
Compiling the UVM scoreboard</h1>
<p>To get the UVM scoreboard compiled you need to add <b><a class="el" href="pk__syoscb_8sv_source.html">src/pk_syoscb.sv</a></b> to your list of files that are complied when compiling your testbench. How this is done is highly dependent on the verification environment since some environments compile everything into different libraries and some do not. Refer to your vendor's manual for further information on how to include packages.</p>
<h1><a class="anchor" id="sAcccess"></a>
Accessing the UVM scoreboard from your own code</h1>
<p>Once the UVM scoreboard is compiled with the verification environment, it is accessible either by explicit scoping:</p>
<div class="fragment"><div class="line">class myclass;</div><div class="line">  pk_syoscb::cl_syoscb my_new_scb;</div><div class="line">  ...</div></div><!-- fragment --><p>or by importing the complete package into your scope:</p>
<div class="fragment"><div class="line">import pk_syoscb::*;</div><div class="line"></div><div class="line">class myclass;</div><div class="line">  cl_syoscb my_new_scb;</div><div class="line">  ...</div></div><!-- fragment --><h1><a class="anchor" id="sFactory"></a>
Factory overrides</h1>
<p>Before instantiating the scoreboard, the desired queue type and compare algorithm need to be set in the scoreboard's configuration object. This is done by factory overrides since the queue type and compare algorithm can be changed on a per-test basis.</p>
<p><b>NOTE: This MUST be done before creating the scoreboard!</b></p>
<p>The queue type and compare algorithm should <b> not </b> be overwritten with a call to the UVM configuration databse. Instead, the scoreboard configuration object should be used.</p>
<p>The factory overrides are done in the build phase of the <a class="el" href="classcl__syoscb.html" title="Top level class implementing the root of the SyoSil UVM scoreboard. ">cl_syoscb</a>, depending on the value of the <a class="el" href="classcl__syoscb__cfg.html#a7311e262791c3f3a0e065b8abdf541f6" title="Queue topology used in the SCB. Defaults to pk_syoscb::SYOSCB_QUEUE_USER_DEFINED. ...">cl_syoscb_cfg.queue_type</a> and <a class="el" href="classcl__syoscb__cfg.html#a307bb9df27ad032508bf9fe7fda68346" title="Compare strategy used in the SCB. Defaults to pk_syoscb::SYOSCB_COMPARE_IO. ">cl_syoscb_cfg.compare_type</a> configuration knobs. If no overwriting is performed, the test will fail, as the default queue and comparison types are set to <code>USER_DEFINED</code>, a placeholder value for user-defined queue types and comparison types.</p>
<p>The scoreboard comes with a number of built-in queue types and comparison algorithms (see <a class="el" href="pQueueImplementationNotes.html">Queue implementation notes</a> and <a class="el" href="pCompareImplementationNotes.html">Compare implementation notes</a>). The following queue implementations are available:</p>
<ol type="1">
<li>Standard SV queue (<a class="el" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue. ">cl_syoscb_queue_std</a>)</li>
<li>MD5 queue (<a class="el" href="classcl__syoscb__queue__hash__md5.html" title="MD5 implementation of a hash queue which optimizes the OOO compare. ">cl_syoscb_queue_hash_md5</a>)</li>
</ol>
<p>and the following compare algorithms are available:</p>
<ol type="1">
<li>Out of Order (OOO, <a class="el" href="classcl__syoscb__compare__ooo.html" title="Class which implements the out of order compare algorithm. ">cl_syoscb_compare_ooo</a>)</li>
<li>In Order (IO, <a class="el" href="classcl__syoscb__compare__io.html" title="Implementation of the in-order comparison algorithm for N queues. ">cl_syoscb_compare_io</a>).</li>
<li>In Order with 2 queues, high performance (IO_2HP, <a class="el" href="classcl__syoscb__compare__io__2hp.html" title="Implementation of the 2-queue, high speed in-order comparison algorithm. ">cl_syoscb_compare_io_2hp</a>)</li>
<li>In Order by Producer (IOP, <a class="el" href="classcl__syoscb__compare__iop.html" title="Class which implements the in order by producer compare algorithm. ">cl_syoscb_compare_iop</a>)</li>
</ol>
<p>Setting the queue topology is done with the method <code>set_queue_type</code> in <a class="el" href="classcl__syoscb__cfg.html" title="Configuration class for the SyoSil UVM scoreboard. ">cl_syoscb_cfg</a>. For example, the following line shows how to select the MD5 queue topology for a scoreboard.</p>
<div class="fragment"><div class="line">this.syoscb_cfg.set_queue_type(pk_syoscb::SYOSCB_QUEUE_MD5);</div></div><!-- fragment --><p>The following line shows an example of how to change the compare strategy. Here, OOO comparisons are enabled.</p>
<div class="fragment"><div class="line">this.syoscb_cfg.set_compare_type(pk_syoscb::SYOSCB_COMPARE_OOO);</div></div><!-- fragment --><p>All of the enum values used for selecting queue type and compare algorithm can be found in <b><a class="el" href="syoscb__common_8svh_source.html">src/syoscb_common.svh</a></b>.</p>
<h1><a class="anchor" id="sInstantiation"></a>
Instantiating the UVM scoreboard</h1>
<p>The UVM scoreboard itself needs to be instantiated along with the configuration object. The simplest way to to this is to add the UVM scoreboard and the configuration object to the UVM environment â€“ note that the configuration object is passed to the scoreboard via the <code>uvm_config_db</code>.</p>
<div class="fragment"><div class="line">import pk_syoscb::*;</div><div class="line"></div><div class="line">class cl_scbtest_env extends uvm_env;</div><div class="line"></div><div class="line">  cl_syoscb     syoscb;</div><div class="line">  cl_syoscb_cfg syoscb_cfg;</div><div class="line"></div><div class="line">  `uvm_component_utils_begin(cl_scbtest_env)</div><div class="line">    `uvm_field_object(syoscb,     UVM_ALL_ON)</div><div class="line">    `uvm_field_object(syoscb_cfg, UVM_ALL_ON)</div><div class="line">  `uvm_component_utils_end</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">endclass: cl_scbtest_env</div><div class="line"></div><div class="line">function void cl_scbtest_env::build_phase(uvm_phase phase);</div><div class="line">  super.build_phase(phase);</div><div class="line"></div><div class="line">  // Create the scoreboard configuration object</div><div class="line">  this.syoscb_cfg = cl_syoscb_cfg::type_id::create(&quot;syoscb_cfg&quot;);</div><div class="line"></div><div class="line">  // Pass the scoreboard configuration object to the config_db</div><div class="line">  uvm_config_db #(cl_syoscb_cfg)::set(this, &quot;syoscb&quot;, &quot;cfg&quot;, this.syoscb_cfg);</div><div class="line"></div><div class="line">  // Create the scoreboard</div><div class="line">  this.syoscb = cl_syoscb::type_id::create(&quot;syoscb&quot;, this);</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">endfunction: build_phase</div></div><!-- fragment --><h1><a class="anchor" id="sConfiguration"></a>
Configuring the UVM scoreboard</h1>
<p>A default configuration is not created, so a configuration object must be constructed, configured and set in the UVM configuration database for each scoreboard instance to pick it up. One must create a separate scoreboard configuration object for each scoreboard instance. It cannot be reused! The following example shows a scoreboard with two queues, Q1 and Q2, with Q1 as the primary queue. Furthermore, one producer P1 is added to both queues:</p>
<div class="fragment"><div class="line">function void cl_scbtest_env::build_phase(uvm_phase phase);</div><div class="line">  super.build_phase(phase);</div><div class="line"></div><div class="line">  // Create the scoreboard configuration object</div><div class="line">  this.syoscb_cfg = cl_syoscb_cfg::type_id::create(&quot;syoscb_cfg&quot;);</div><div class="line"></div><div class="line">  // Configure the scoreboard</div><div class="line">  this.syoscb_cfg.set_queues({&quot;Q1&quot;, &quot;Q2&quot;});</div><div class="line">  void&#39;(this.syoscb_cfg.set_primary_queue(&quot;Q1&quot;));</div><div class="line">  void&#39;(this.syoscb_cfg.set_producer(&quot;P1&quot;, {&quot;Q1&quot;, &quot;Q2&quot;}));</div><div class="line"></div><div class="line">  // Pass the scoreboard configuration object to the config_db</div><div class="line">  uvm_config_db #(cl_syoscb_cfg)::set(this, &quot;syoscb&quot;, &quot;cfg&quot;, this.syoscb_cfg);</div><div class="line"></div><div class="line">  // Create the scoreboard</div><div class="line">  this.syoscb = cl_syoscb::type_id::create(&quot;syoscb&quot;, this);</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">endfunction: build_phase</div></div><!-- fragment --><p>For more info about the configuration options, see pConfiguration.</p>
<h2><a class="anchor" id="ssBuild"></a>
Full build phase</h2>
<p>The full build phase of our example environment <code>cl_scbtest_env</code> is shown here for completeness:</p>
<div class="fragment"><div class="line">function void cl_scbtest_env::build_phase(uvm_phase phase);</div><div class="line">  super.build_phase(phase);</div><div class="line"></div><div class="line">  // Use the MD5 queue implementation as scoreboard queue</div><div class="line">  this.syoscb_cfg.set_queue_type(pk_syoscb::SYOSCB_QUEUE_MD5);</div><div class="line"></div><div class="line">  // Set the compare strategy to be OOO</div><div class="line">  this.syoscb_cfg.set_compare_type(pk_syoscb::SYOSCB_COMPARE_OOO);</div><div class="line"></div><div class="line">  // Create the scoreboard configuration object</div><div class="line">  this.syoscb_cfg = cl_syoscb_cfg::type_id::create(&quot;syoscb_cfg&quot;);</div><div class="line"></div><div class="line">  // Configure the scoreboard</div><div class="line">  this.syoscb_cfg.set_queues({&quot;Q1&quot;, &quot;Q2&quot;});</div><div class="line">  void&#39;(this.syoscb_cfg.set_primary_queue(&quot;Q1&quot;));</div><div class="line">  void&#39;(this.syoscb_cfg.set_producer(&quot;P1&quot;, {&quot;Q1&quot;, &quot;Q2&quot;}));</div><div class="line"></div><div class="line">  // Pass the scoreboard configuration object to the config_db</div><div class="line">  uvm_config_db #(cl_syoscb_cfg)::set(this, &quot;syoscb&quot;, &quot;cfg&quot;, this.syoscb_cfg);</div><div class="line"></div><div class="line">  // Create the scoreboard</div><div class="line">  this.syoscb = cl_syoscb::type_id::create(&quot;syoscb&quot;, this);</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">endfunction: build_phase</div></div><!-- fragment --><h1><a class="anchor" id="sAddSequenceItems"></a>
Add sequence items to the scoreboard</h1>
<h2><a class="anchor" id="ssFunctionAPIHookUp"></a>
Function based API hook up</h2>
<p>The function based API is very easy to use once you have done the configuration and instantiation of the scoreboard as described above.</p>
<p>Whenever you need to add a UVM sequence item to a queue produced by a specified producer, simply invoke the <a class="el" href="classcl__syoscb.html#a26c59c91c6fdd22f29a411cba2d5ed8f" title=" Scoreboard API: Adds a uvm_sequence_item to a given queue for a given producer. ">cl_syoscb::add_item()</a> method:</p>
<div class="fragment"><div class="line">// *NOTE*: Assumes syoscb is handle to an instance of the scoreboard and</div><div class="line">//         item1 is a handle to a UVM sequence item</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">// Insert UVM sequence item for queue: Q1, for producer: P1</div><div class="line">syoscb.add_item(&quot;Q1&quot;, &quot;P1&quot;, item1);</div></div><!-- fragment --><p>Invoking the <a class="el" href="classcl__syoscb.html#a26c59c91c6fdd22f29a411cba2d5ed8f" title=" Scoreboard API: Adds a uvm_sequence_item to a given queue for a given producer. ">cl_syoscb::add_item()</a> method will wrap the UVM sequence item in a <a class="el" href="classcl__syoscb__item.html" title="The UVM scoreboard item which wraps uvm_sequence_item . ">cl_syoscb_item</a> object, add it to the correct queue and finally invoke the configured compare algorithm.</p>
<p>The UVM environment will typically contain a handle to the scoreboard as described above. This can then be utilized if UVM sequence item needs to be added from a test case:</p>
<div class="fragment"><div class="line">class cl_scbtest_seq_item extends uvm_sequence_item;</div><div class="line">  //-------------------------------------</div><div class="line">  // Randomizable variables</div><div class="line">  //-------------------------------------</div><div class="line">  rand int unsigned int_a;</div><div class="line"></div><div class="line">  //-------------------------------------</div><div class="line">  // UVM Macros</div><div class="line">  //-------------------------------------</div><div class="line">  `uvm_object_utils_begin(cl_scbtest_seq_item)</div><div class="line">    `uvm_field_int(int_a, UVM_ALL_ON)</div><div class="line">  `uvm_object_utils_end</div><div class="line"></div><div class="line">  //-------------------------------------</div><div class="line">  // Constructor</div><div class="line">  //-------------------------------------</div><div class="line">  function cl_scbtest_seq_item::new (string name = &quot;cl_scbtest_seq_item&quot;);</div><div class="line">     super.new(name);</div><div class="line">  endfunction</div><div class="line">endclass: cl_scbtest_seq_item</div><div class="line"></div><div class="line">class cl_scbtest_test extends uvm_test;</div><div class="line">  //-------------------------------------</div><div class="line">  // Non randomizable variables</div><div class="line">  //-------------------------------------</div><div class="line">  cl_scbtest_env scbtest_env;</div><div class="line"></div><div class="line">  //-------------------------------------</div><div class="line">  // UVM Macros</div><div class="line">  //-------------------------------------</div><div class="line">  `uvm_component_utils(cl_scbtest_test)</div><div class="line"></div><div class="line">  //-------------------------------------</div><div class="line">  // Constructor</div><div class="line">  //-------------------------------------</div><div class="line">  function new(string name = &quot;cl_scbtest_test&quot;, uvm_component parent = null);</div><div class="line">    super.new(name, parent);</div><div class="line">  endfunction: new</div><div class="line"></div><div class="line">  //-------------------------------------</div><div class="line">  // UVM Phase methods</div><div class="line">  //-------------------------------------</div><div class="line">  function void build_phase(uvm_phase phase);</div><div class="line">    super.build_phase(phase);</div><div class="line">    scbtest_env = cl_scbtest_env::type_id::create(&quot;scbtest_env&quot;, this);</div><div class="line">  endfunction: build_phase</div><div class="line"></div><div class="line">  task run_phase(uvm_phase phase);</div><div class="line">    super.run_phase(phase);</div><div class="line">    begin</div><div class="line">      cl_scbtest_seq_item item1;</div><div class="line">      item1 = cl_scbtest_seq_item::type_id::create(&quot;item1&quot;);</div><div class="line">      item1.int_a = &#39;h3a;</div><div class="line">      scbtest_env.syoscb.add_item(&quot;Q1&quot;, &quot;P1&quot;, item1);</div><div class="line">    end</div><div class="line">    begin</div><div class="line">      cl_scbtest_seq_item item1;</div><div class="line">      item1 = cl_scbtest_seq_item::type_id::create(&quot;item1&quot;);</div><div class="line">      item1.int_a = &#39;h3a;</div><div class="line">      scbtest_env.syoscb.add_item(&quot;Q2&quot;, &quot;P1&quot;, item1);</div><div class="line">    end</div><div class="line">  endtask: run_phase</div><div class="line">endclass: cl_scbtest_test</div></div><!-- fragment --><h2><a class="anchor" id="ssTLMAPIHookUp"></a>
TLM based API hook up</h2>
<p>The TLM API is even easier to use than the function based API. The scoreboard provides a generic UVM subscribers for each producer on each queue. This subscriber can cbe onnected to anything which has a UVM analysis port (e.g. a UVM monitor). Typically, the UVM agents inside the UVM environment contain one or more monitors with UVM analysis ports which should be connected to the scoreboard. The following example shows two agents, each of which has a monitor. The monitors are connected to Q1 and Q2 in the scoreboard, acting as producer P1:</p>
<div class="fragment"><div class="line">import pk_syoscb::*;</div><div class="line"></div><div class="line">class cl_scbtest_env extends uvm_env;</div><div class="line"></div><div class="line">  cl_syoscb     syoscb;</div><div class="line">  cl_syoscb_cfg syoscb_cfg;</div><div class="line">  myagent       agent1;</div><div class="line">  myagent       agent2;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  function void build_phase(uvm_phase phase);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    // Configure and create the scoreboard</div><div class="line">    // Create and configure the agents</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">  endfunction: build_phase</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  function void connect_phase(uvm_phase phase);</div><div class="line">    super.connect_phase(phase);</div><div class="line"></div><div class="line">    begin</div><div class="line">      cl_syoscb_subscriber subscriber;</div><div class="line"></div><div class="line">      // Get the subscriber for Producer: P1 for queue: Q1 and connect it</div><div class="line">      // to the UVM monitor producing transactions for this queue</div><div class="line">      subscriber = this.syoscb.get_subscriber(&quot;Q1&quot;, &quot;P1&quot;);</div><div class="line">      this.agent1.mon.&lt;analysis port&gt;.connect(subscriber.analysis_export);</div><div class="line"></div><div class="line">      // Get the subscriber for Producer: P1 for queue: Q2 and connect it</div><div class="line">      // to the UVM monitor producing transactions for this queue</div><div class="line">      subscriber = this.syoscb.get_subscriber(&quot;Q2&quot;, &quot;P1&quot;);</div><div class="line">      this.agent1.mon.&lt;analysis port&gt;.connect(subscriber.analysis_export);</div><div class="line">    end</div><div class="line">  endfunction: connect_phase</div><div class="line">endclass: cl_scbtest_env</div></div><!-- fragment --><h1><a class="anchor" id="sMultipleSCBintances"></a>
Multiple SCB instances &amp; filter transforms</h1>
<p>The SyoSil UVM scoreboard also comes with a scoreboard wrapper, <a class="el" href="classcl__syoscbs__base.html" title="Base class for a wrapper around multiple SyoSil Scoreboards. ">cl_syoscbs_base</a>, which can be used to instantiate several scoreboards with similar configurations.</p>
<p>A configuration wrapper, <a class="el" href="classcl__syoscbs__cfg.html" title="Configuration object for the cl_syoscbs_base scoreboard wrapper. ">cl_syoscbs_cfg</a>, is used to configure the scoreboard wrapper. The configuration wrapper contains N configuration objects, one for each wrapped scoreboard. The wrapped scoreboards may have different queue / producer names and numbers of queues/producers, or they may be the same. See the figure below for a UML diagram of the relationship between individual scoreboards and their configurations, and the scoreboard wrapper and its configuration object.</p>
<div class="image">
<img src="syoscbs.drawio.png" alt="syoscbs.drawio.png"/>
</div>
 <h2><a class="anchor" id="ssFilterTransforms"></a>
Filter transforms</h2>
<p>Since UVM analysis ports are parameterized with the types of items they will accept, and the SyoSil scoreboard's <a class="el" href="classcl__syoscb__subscriber.html" title="Generic subscriber for the scoreboard. ">cl_syoscb_subscriber</a> expects input items to be of type <code>uvm_sequence_item</code>, a transformation must be used to upcast sequence items to this datatype before they are inserted. When using a single scoreboard, this transformation can easily be instantiated manually, or items can be upcast in a monitor before being written to the attached subscriber.</p>
<p>In the case where 100's or 1000's of scoreboards are used, manually instantiating and connecting all of these transforms can become tedious. Instead, the scoreboard wrapper offers <b>filter transforms</b> to automate the process. When creating the scoreboard wrapper <a class="el" href="classcl__syoscbs.html" title="Default implementation of a scoreboard wrapper. ">cl_syoscbs</a>, it must be parameterized with the type of sequence items that will be input. It then automatically instantiates a transformation object for each subscriber, and connects its output to the input of the subscriber. Now, instead of retrieving the subscribers for each queue/producer, a filter transform for each scoreboard's queue/producer combination should be retrieved.</p>
<p>The default filter transform <a class="el" href="classpk__utils__uvm_1_1filter__trfm.html" title="Base class for a filter transformation. ">pk_utils_uvm::filter_trfm</a>, included in <b><a class="el" href="pk__utils__uvm_8sv_source.html">lib/pk_utils_uvm.sv</a></b>, simply upcasts its input to a <code>uvm_sequence_item</code> before passing it on to the scoreboard. If more complex transforms are required, you can extend <a class="el" href="classcl__syoscbs__base.html" title="Base class for a wrapper around multiple SyoSil Scoreboards. ">cl_syoscbs_base</a> and implement cl_syoscb_base::create_filter to suit your needs.</p>
<p>The class <a class="el" href="classcl__syoscbs__base.html" title="Base class for a wrapper around multiple SyoSil Scoreboards. ">cl_syoscbs_base</a> serves as the base class for the scoreboard wrapper, and a default implementation is included in <a class="el" href="classcl__syoscbs.html" title="Default implementation of a scoreboard wrapper. ">cl_syoscbs</a>. The default implementation should be enough for most applications</p>
<p>In the example below, a scoreboard wrapper with 10 scoreboards is created. Each scoreboard has two queues, DUT and REF, each of which has two producers, P1 and P2. In the environment's build phase, the scoreboard wrapper and config object are created. After initializing the configuration object, it is passed to the scoreboard wrapper with the UVM configuration database. In the environment's connect phase, each DUT agent is connected to filter transforms associated with their respective scoreboard. The parameter <code>FIN</code> is the input type to the filter transforms. The filter transforms convert this type to a <code>uvm_sequence_item</code> which is passed into the scoreboard.</p>
<div class="fragment"><div class="line">import pk_syoscb::*;</div><div class="line"></div><div class="line">class cl_scbs_env#(type FIN = my_seq_item) extends uvm_env;</div><div class="line">  int              NUM_SCB = 10;</div><div class="line">  cl_syoscbs#(FIN) syoscbs;</div><div class="line">  cl_syoscbs_cfg   syoscbs_cfg;</div><div class="line">  dut_agent        dut_agents[NUM_SCB];</div><div class="line">  ref_agent        ref_agents[NUM_SCB];</div><div class="line">  string           producers[] = &#39;{&quot;P1&quot;, &quot;P2&quot;};</div><div class="line">  string           queues[] = &#39;{&quot;DUT&quot;, &quot;REF&quot;};</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  function void build_phase(uvm_phase phase);</div><div class="line">    super.build_phase(phase);</div><div class="line">    this.syoscbs_cfg = cl_syoscbs_cfg::type_id::create(&quot;syoscbs_cfg&quot;);</div><div class="line">    //Create an scb wrapper named my_syoscbs with 10 scoreboards. They will be named &quot;scb[i]&quot;,</div><div class="line">    //and each will have queues named &quot;DUT&quot;, &quot;REF&quot;, and each queue will have producers &quot;P1&quot; and &quot;P2&quot;</div><div class="line">    this.syoscbs_cfg.init(&quot;syoscbs&quot;, NUM_SCB, &quot;scb&quot;, queues, producers);</div><div class="line"></div><div class="line">    uvm_config_db #(cl_syoscbs_cfg)::set(this, &quot;&quot;, &quot;syoscbs&quot;, this.syoscbs_cfg);</div><div class="line"></div><div class="line">    this.syoscbs = cl_syoscbs#(FIN)::type_id::create(&quot;syoscbs&quot;);</div><div class="line"></div><div class="line">    ... //Create and configure all dut agents and ref agents</div><div class="line">  endfunction: build_phase</div><div class="line"></div><div class="line">  function void connect_phase(uvm_phase phase);</div><div class="line">    //Each DUT agent is connected to a separate scoreboard</div><div class="line">    foreach(dut_agents[i]) begin</div><div class="line">      pk_utils_uvm::filter_trfm#(FIN, uvm_sequence_item) filter_trfm_p1;</div><div class="line">      pk_utils_uvm::filter_trfm#(FIN, uvm_sequence_item) filter_trfm_p2;</div><div class="line"></div><div class="line">      //Get handles to the filter transforms connected to DUT queue for P1 and P2, scoreboard &#39;i&#39;</div><div class="line">      filter_trfm_p1 = this.syoscbs.get_filter_trfm(&quot;DUT&quot;, &quot;P1&quot;, i);</div><div class="line">      filter_trfm_p2 = this.syoscbs.get_filter_trfm(&quot;DUT&quot;, &quot;P2&quot;, i);</div><div class="line">      //Connect agents to filter transforms</div><div class="line">      dut_agents[i].p1_anls_port.connect(filter_trfm_p1.analysis_export);</div><div class="line">      dut_agents[i].p2_anls_port.connect(filter_trfm_p2.analsysi_export);</div><div class="line">    end</div><div class="line">    // ... Perform the same procedure for reference model ports</div><div class="line">  endfunction: connect_phase</div></div><!-- fragment --><p>The included testcases also include several tests using the scoreboard wrapper, which can be used as a starting point. See <a class="el" href="classcl__scbs__test__base.html" title="Base class for all SCBs tests. ">cl_scbs_test_base</a> and cl_tb_env_scbs. See <b>tb/test/scbs/cl_scbs_test_base</b> and <b>tb/cl_tb_env_scbs</b>. </p>
</div></div><!-- contents -->
<!--*************************************************************************-->
<!-- $Id$          -->
<!--*************************************************************************-->
<!--   This program is free software: you can redistribute it and/or modify  -->
<!--   it under the terms of the GNU General Public License as published by  -->
<!--   the Free Software Foundation, either version 3 of the License, or     -->
<!--   (at your option) any later version.                                   -->
<!--                                                                         -->
<!--   This program is distributed in the hope that it will be useful,       -->
<!--   but WITHOUT ANY WARRANTY; without even the implied warranty of        -->
<!--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         -->
<!--   GNU General Public License for more details.                          -->
<!--                                                                         -->
<!--   You should have received a copy of the GNU General Public License     -->
<!--   along with this program.  If not, see http://www.gnu.org/licenses/.   -->
<!--                                                                         -->
<!--*************************************************************************-->
<!-- Title:        IDV Doxygen Footer File                                   -->
<!-- Description:  This file is a doxygen footer with the IDV logo and a     -->
<!--               and a reference to the GNU FDL License.                   -->
<!--                                                                         -->
<!-- Original Author: Sean O'Boyle                                           -->
<!-- Contact:         seanoboyle@intelligentdv.com                           -->
<!-- Company:         Intelligent Design Verification                        -->
<!-- Company URL:     http://intelligentdv.com                               -->
<!--                                                                         -->
<!-- Download the most recent version here:                                  -->
<!--                  http://intelligentdv.com/downloads                     -->
<!--                                                                         -->
<!-- File Bugs Here:  http://bugs.intelligentdv.com                          -->
<!--        Project:  DoxygenFilterSV                                        -->
<!--                                                                         -->
<!-- File: idv_dox_header.xml                                                -->
<!-- $LastChangedBy$                                            -->
<!-- $LastChangedDate$        -->
<!-- $LastChangedRevision$                                             -->
<!--                                                                         -->
<!--*************************************************************************-->
<br>
<table border="1" width = "100%">
  <tr>
    <td width = "20%" style="text-align: center">
     <a href="https://syosil.com">
      <img src="syosil.jpg" width="70%">
     </a>
    </td>
    <td width = "60%">
       <address style="text-align: center;">
       Project: SyoSil ApS UVM Scoreboard, Revision: 1.0.3.0<br>
       <br>
       Copyright 2014-2022 SyoSil ApS<br>
       All Rights Reserved Worldwide<br>
       <br>
      Licensed under the Apache License, Version 2.0 (the "License"); you may not
      use this file except in compliance with the License.  You may obtain a copy of
      the License at<br>
      <br>
       <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br>
      <br>
      Unless required by applicable law or agreed to in writing, software distributed under the License is
      distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied. See the License for the specific language governing permissions and limitations under
      the License.
      </address>
    </td>
    <td width = "20%">
      <address style="text-align: center;"><small>
      <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a><br>
      <a href="http://www.doxygen.org/index.html">Doxygen</a> Version: 1.8.14<br>
      Generated with <a href="http://www.intelligentdv.com/index.html">IDV SV Filter</a> Version: 2.6.3<br>
      Fri Sep 2 2022 14:40:35</small></address>
   </td>
  </tr>
</table>
<address style="text-align: left;"><small>
Find a documentation bug?  Report bugs to: <a href="mailto:scoreboard@syosil.com">scoreboard@syosil.com</a>
</small></address>
</body>
</html>
